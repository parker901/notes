<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chkkn notes</title>
  <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
</head>
<body>
  <a href="/">back</a>
  <div class="markdown-body">
    <h2>JavaScript</h2>
<pre class="hljs"><code># use console.log() to visualise variable or expression

function sum(a, b){
    console.log(a);
    console.log(a + b);
    return a + b;
}
sum(1,3);
</code></pre>
<pre class="hljs"><code># Must include return in js if not it will return undefined.

function sum(x,y){
    return x + y;
}

</code></pre>
<h3>String property</h3>
<pre class="hljs"><code>let text = &quot;Hello World&quot;;
text.length; // 11

# length does not have () because it's a property not method
</code></pre>
<pre class="hljs"><code>&quot;BLUE&quot;.toLowerCase(); // &quot;blue&quot;;
&quot;red&quot;.toUpperCase(); // &quot;RED&quot;;
</code></pre>
<h4>Characters</h4>
<pre class="hljs"><code>const language = &quot;JavaScript&quot;;

language[0]; // first character
language[1]; // second character
language[2]; // third character

language[language.length - 2]; // &quot;p&quot; because it's second to last character from &quot;JavaScript&quot;
</code></pre>
<pre class="hljs"><code># .at() reads character at certain index

const language = &quot;JavaScript&quot;;
language.at(0); // &quot;J&quot;
language.at(1); // &quot;a&quot;
language.at(-1); // &quot;t&quot;
language.at(-2); // &quot;p&quot;
</code></pre>
<h4>Substrings</h4>
<p>Substrings is a portion of a string e.g. rain in brain.</p>
<pre class="hljs"><code>const language = &quot;JavaScript&quot;;
language.substring(1,4); // &quot;ava&quot;

# indexEnd parameter is optional.
language.substring(4); //&quot;Script&quot;
</code></pre>
<p><code>.substr</code> is deprecated.</p>
<h4>Plus operator</h4>
<pre class="hljs"><code>&quot;Hello&quot; + &quot;World&quot; // &quot;HelloWorld&quot;
</code></pre>
<pre class="hljs"><code>let prefix = &quot;Mrs.&quot;;
let name = &quot;Sam&quot;;
let string = prefix + &quot; &quot; + name; // &quot;Mrs. Sam&quot;
</code></pre>
<pre class="hljs"><code>let name = &quot;Sam&quot;;
name = name + &quot; Blue&quot;;
console.log(name); // &quot;Sam Blue&quot;

# same as
name += &quot; Blue&quot;;
</code></pre>
<h4>Template strings</h4>
<p>Template strings support interpolation, means you can write variable in your string.</p>
<pre class="hljs"><code>`This is a template string`

# Multiline strings
let text = `This is a multiline
string that
just works!`
</code></pre>
<pre class="hljs"><code>let language = &quot;JavaScript&quot;;
`I am learning ${language}`;
</code></pre>
<h3>Numbers</h3>
<pre class="hljs"><code>Example of numbers in JS
1
2
-5
3.5
2000
2021
-23.51
</code></pre>
<pre class="hljs"><code># Using numeric separator (_) makes it easier to read
let nb = 1_000; // equivalent to 1000
let nc = 1_000_000; // 1 million
</code></pre>
<pre class="hljs"><code># number to string
let answer = 42;
answer.toString();
</code></pre>
<h4>NaN</h4>
<p>Not a number.</p>
<pre class="hljs"><code>&quot;abc&quot; * 4; // NaN

# Sign something wrong with the code e.g. not converting string to a number
</code></pre>
<pre class="hljs"><code># Convert string to number
let str = &quot;42&quot;;
Number.parseInt(str, 10); //42

# Global objecet called Number which contains method parseInt
# Parameter 2 - radix: decimal 10, binary 2
</code></pre>
<p><code>parseInt()</code> works the same but use the modern <code>Number.parseInt</code></p>
<h4>Operations</h4>
<pre class="hljs"><code>8%2; // Devision remainder is 0
7%2 // Devision remainder is 1
</code></pre>
<pre class="hljs"><code>Math.round(2.6); // 3
Math.floor(2.6); // 2
Math.ceil(2.6); // 3

Math.round(2.5); // 3
Math.floor(2.5); // 2
Math.ceil(2.5); // 3
</code></pre>
<h3>Variables</h3>
<pre class="hljs"><code># let

let language = &quot;C++&quot;;
language = &quot;JavaScript&quot;;

let sum = 0;
sum += 1;
</code></pre>
<pre class="hljs"><code># const cannot be re-assigned

const language = &quot;C++&quot;;
language = &quot;Python&quot; // Type error
</code></pre>
<p>General rule is always go with <code>const</code> until you realised you need to re-assigned. <code>var</code> can still be used but its discourage to use.</p>
<h3>Conditions</h3>
<pre class="hljs"><code>const grade = 3;

if (grade &gt;= 10) {
    console.log(&quot;Passing grade&quot;);
} else {
    console.log(&quot;Failing grade&quot;);
}
</code></pre>
<pre class="hljs"><code>const grade = 10;

if (grade &gt; 10) {
    console.log(&quot;Passing grade&quot;);
} else if (grade === 10) {
    console.log(&quot;Passing on the limit&quot;);
} else {
    console.log(&quot;Failing grade&quot;);
}
</code></pre>
<h4>Ligatures</h4>
<p>This can be enabled on your code editor.</p>
<pre class="hljs"><code>&gt;= for &gt;=
&lt;= for &lt;=
=== for ===
!== for !==
</code></pre>
<h4>Advanced if</h4>
<pre class="hljs"><code># Dropping the else

function canVote(age) {
    if (age &gt;= 18) {
        return true;
    }
    return false;
}
</code></pre>
<p>Note: Use triple equal <code>===</code> instead of <code>==</code>. With <code>==</code> js will try to convert both values into the same data type.</p>
<h4>Returning booleans</h4>
<pre class="hljs"><code># Refactor boolean

function isPassing(grade) {
    return grade &gt;= 10;
}
</code></pre>
<h4>Even &amp; Odd</h4>
<pre class="hljs"><code>// even numbers
4 % 2 // 0
6 % 2 // 0
8 % 2 // 0
10 % 2 // 0

// odd numbers
3 % 2 // 1
5 % 2 // 1
7 % 2 // 1
9 % 2 // 1
</code></pre>
<h3>Arrays</h3>
<pre class="hljs"><code>const users = []; // empty array
const grades = [10, 8, 13, 15]; // array of numbers
const attendees = [&quot;Sam&quot;, &quot;Alex&quot;]; // array of strings
const values = [10, false, &quot;John&quot;]; // mixed
</code></pre>
<pre class="hljs"><code># .length property

[].length; // 0

const grades = [10, 8, 13, 15];
grades.length; // 4
</code></pre>
<pre class="hljs"><code># get element by index

const users = [&quot;Sam&quot;, &quot;Alex&quot;, &quot;Charley&quot;];
users[1]; //&quot;Alex&quot;

# using .at(index)

const users = [&quot;Sam&quot;, &quot;Alex&quot;, &quot;Charley&quot;];
users.at(1); //&quot;Alex&quot;
users.at(-2); //&quot;Alex&quot;
</code></pre>
<pre class="hljs"><code># adding a element

const numbers = [10, 8, 13, 15];
numbers.push(20); // returns 5 (the new length of the array)
console.log(numbers); // [10, 8, 13, 15, 20];
</code></pre>
<p>Even though the array is <code>const</code>, new data can still be pushed. This is because <code>const</code> means you can only assign variable once but doesn't mean the variable is immutable. Benefit to use <code>const</code> is the variable will always be an array.</p>
<pre class="hljs"><code>const numbers = []; // start with empty array
numbers.push(10); // returns 1 (new length of array)
console.log(numbers); // [10] (still an array but content changed)
numbers.push(20); // returns 2 (new length of array)
console.log(numbers); // [10, 20] (still an array but content changed)
</code></pre>
<h4>Array forEach</h4>
<pre class="hljs"><code># Looping through an array

const grades = [10, 8, 13];

grades.forEach(function(grade) {
    // do something with individual grade
    console.log(grade);
});
</code></pre>
<p><code>forEach</code> takes a callback function as an argument which is called once for each element in an array.
The callback function here it not actually executing the function but is defining how the function should behave if it's executed. The function definition is passed to <code>forEach</code> function. In this case <code>grade</code> is the function definition.</p>
<h4>Naming variables</h4>
<p>Use <strong>plural</strong> for <strong>array</strong> and <strong>singular</strong> for <strong>item</strong> of the array.<br>
E.g.</p>
<ul>
<li>grades =&gt; item is <strong>grade</strong></li>
<li>people =&gt; item is <strong>person</strong></li>
</ul>
<h4>Returning from loop</h4>
<p>In the function that calls <code>foreach</code> there are two 2 functions. The <code>return</code> should be outside the <code>foreach</code> function. Returning inside the function is not useful because it's going to return inside the callback function and <code>.foreach()</code> will always return <code>undefined</code>.</p>
<pre class="hljs"><code># Correct return

function logUserIds(userIds) {
    userIds.forEach(function(userId) {
        console.log(userId);
    });
    return true; // âœ… return from the logUserIds function
}
</code></pre>
<h4>Array filter</h4>
<pre class="hljs"><code># Returns another array with some items of the original array

const numbers = [9, 5, 14, 3, 11];

const numbersAboveTen = numbers.filter(function(number) {
    return number &gt; 10;
});
console.log(numbersAboveTen); // [14, 11]
</code></pre>
<p>The <code>.filter()</code> method expects a callback. JS takes the callback and call it for every singel item in the array.</p>
<h4>Array find</h4>
<pre class="hljs"><code>let names = [&quot;Sam&quot;, &quot;Alex&quot;, &quot;Charlie&quot;];

let result = names.find(function(name) {
  return name === &quot;Alex&quot;;
});
console.log(result); // &quot;Alex&quot;
</code></pre>
<p>The callback will stop calling once the array returns true.</p>
<h4>.filter() vs .find()</h4>
<ol>
<li><code>.filter()</code> always return an array.</li>
<li><code>.find()</code> returns first array item that matches.</li>
</ol>
<h4>Array map</h4>
<p><code>.map(callback)</code> <strong>transform</strong> an array into another.</p>
<pre class="hljs"><code>const numbers = [4, 2, 5, 8];

const doubled = numbers.map(function(number) {
    return number * 2;
});
console.log(doubled); // [8, 4, 10, 16]
</code></pre>
<p>It will be <code>[undefined, undefined].</code> if you forget <code>return</code> in the callback function.</p>
<h4>Array includes(item)</h4>
<p>Method takes an item <code>true</code> if the item exists.</p>
<pre class="hljs"><code>const groceries = [&quot;Apple&quot;, &quot;Peach&quot;, &quot;Tomato&quot;];

groceries.includes(&quot;Tomato&quot;); // true
groceries.includes(&quot;Bread&quot;); // false
</code></pre>
<h4>Array join(glue)</h4>
<p>Use glue to insert separators between items when converted to strings.</p>
<pre class="hljs"><code>const groceries = [&quot;Apple&quot;, &quot;Peach&quot;, &quot;Tomato&quot;];
groceries.join(&quot;; &quot;); // &quot;Apple; Peach; Tomato&quot;
groceries.join(&quot; . &quot;); // &quot;Apple . Peach . Tomato&quot;
</code></pre>
<h3>Objects</h3>
<p>An object is a data type that allows you to group several variables together into one variable that contains keys and values.</p>
<pre class="hljs"><code>const user = {
    id: 1,
    firstName: &quot;Sam&quot;,
    lastName: &quot;Doe&quot;,
    age: 20
};

user.id; // 1
user.firstName; // &quot;Sam&quot;
user.isAdmin; // undefined (property does not exist)

# Updating the property value
user.age = user.age + 1;


</code></pre>
<h3>Arrow functions</h3>
<h4>Default parameters</h4>
<p>In Js if an argument is not passed in the function parameters the code will not fail but instead passed as <code>undefined</code>.</p>
<pre class="hljs"><code>function addOne(number = 0) {
    return number + 1;
}

addOne(2); // 3
addOne(5); // 6
addOne(); // 1

# When calling the function without an argument the default value is set to 0.
</code></pre>
<h4>Function to arrow functions</h4>
<p>node</p>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
